{"language":"Solidity","sources":{"src/FungibleFlipTest.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IBlast.sol\";\nimport \"./IBlastPoints.sol\";\nimport \"openzeppelin-contracts/access/Ownable.sol\";\n\n/**\n *  _______  __    __  .__   __.   _______  __  .______    __       _______     _______  __       __  .______\n * |   ____||  |  |  | |  \\ |  |  /  _____||  | |   _  \\  |  |     |   ____|   |   ____||  |     |  | |   _  \\\n * |  |__   |  |  |  | |   \\|  | |  |  __  |  | |  |_)  | |  |     |  |__      |  |__   |  |     |  | |  |_)  |\n * |   __|  |  |  |  | |  . `  | |  | |_ | |  | |   _  <  |  |     |   __|     |   __|  |  |     |  | |   ___/\n * |  |     |  `--'  | |  |\\   | |  |__| | |  | |  |_)  | |  `----.|  |____    |  |     |  `----.|  | |  |\n * |__|      \\______/  |__| \\__|  \\______| |__| |______/  |_______||_______|   |__|     |_______||__| | _|\n *\n *\n * @dev Coin flip game, built on Blast, where you double up or get rugged. Our protocol\n * implements blast's native features, to take no house rake, and provide true 50/50 odds.\n *\n * Website: https://fungibleflip.io\n * Twitter: https://twitter.com/FungibleFlip\n *\n * @author corbo.eth\n */\ncontract FungibleFlip is Ownable {\n\n    IBlast private blast;\n\n    struct Stats {\n        uint32 lastTen;\n        uint32 numWins;\n        uint32 numLosses;\n        uint32 numChoiceHeads;\n        uint32 numChoiceTails;\n        uint32 numResultHeads;\n        uint32 numResultTails;\n        uint8 streak;\n    }\n\n    struct FlipRequest {\n        uint256 id;\n        uint256 flipAmount;\n        address requester;\n        bool choice;\n    }\n\n    // @dev Current flip id.\n    uint256 public flipId;\n\n    // @dev Minimum contract balance.\n    uint256 public threshold;\n\n    // @dev Gas fee compensation for rng signer.\n    uint256 public rngFee;\n\n    // @dev Allowed wager sizes.\n    uint256[6] public amounts;\n\n    // @dev Used to build leaderboard.\n    address[] public levelOneOrHigher;\n\n    // @dev RNG signer address.\n    address public rngSigner;\n\n    // @dev (Account -> level)\n    mapping(address => uint256) public level;\n\n    // @dev (Account -> experience)\n    mapping(address => uint256) public experience;\n\n    // @dev (Account -> flipId)\n    mapping(address => uint256) public userFlipId;\n\n    // @dev (flipId -> data used for flip txn)\n    mapping(uint256 => FlipRequest) public requests;\n\n    // @dev (Account -> statistics)\n    mapping(address => Stats) public stats;\n\n    event LevelUp(address indexed user, uint256 level);\n\n    event Deposit(address indexed user, uint256 flipId);\n\n    event Result(address indexed user, bool choice, bool result, uint256 amount);\n\n    constructor(\n        address _blast,\n        address _signer,\n        uint256 _threshold,\n        uint256 _rngFee,\n        uint256[6] memory _amounts\n    ) Ownable(msg.sender) {\n        blast = IBlast(_blast);\n        blast.configureClaimableGas();\n        blast.configureAutomaticYield();\n        IBlastPoints(0x2536FE9ab3F511540F2f9e2eC2A805005C3Dd800).configurePointsOperator(_signer);\n        rngSigner = _signer;\n        threshold = _threshold;\n        rngFee = _rngFee;\n        amounts = _amounts;\n    }\n\n    /**\n     * @dev Records and stores user and global statistics after a successful flip. Heads/tails\n     * choice/result count, win/loss count, last ten flips, and current streak are all recorded.\n     */\n    function recordStatistics(address _user, bool _choice, bool _win) internal {\n        address global = address(this);\n\n        stats[global].lastTen = (stats[global].lastTen << 2) & 0xFFFFF;\n        stats[global].lastTen |= uint32(_choice ? 1 : 0) << 1 | (_win ? 1 : 0);\n\n        stats[_user].lastTen = (stats[_user].lastTen << 2) & 0xFFFFF;\n        stats[_user].lastTen |= uint32(_choice ? 1 : 0) << 1 | (_win ? 1 : 0);\n\n        bool winStreak = stats[_user].streak >> 7 == 1;\n        uint8 streakLength = stats[_user].streak & 0x7F;\n\n        if (_choice) {\n            stats[global].numChoiceHeads++;\n            stats[_user].numChoiceHeads++;\n            if(_win) {\n                stats[global].numResultHeads++;\n                stats[_user].numResultHeads++;\n            } else {\n                stats[global].numResultTails++;\n                stats[_user].numResultTails++;\n            }\n        } else {\n            stats[global].numChoiceTails++;\n            stats[_user].numChoiceTails++;\n            if(_win) {\n                stats[global].numResultTails++;\n                stats[_user].numResultTails++;\n            } else {\n                stats[global].numResultHeads++;\n                stats[_user].numResultHeads++;\n            }\n        }\n\n        if (_win) {\n            stats[global].numWins++;\n            stats[_user].numWins++;\n\n            if (winStreak) streakLength++;\n            else streakLength = 1;\n\n            stats[_user].streak = (1 << 7) | streakLength;\n        } else {\n            stats[global].numLosses++;\n            stats[_user].numLosses++;\n\n            if (!winStreak) streakLength++;\n            else streakLength = 1;\n\n            stats[_user].streak = streakLength;\n        }\n    }\n\n    /**\n     * @dev Increases an accounts experience after a flip is completed, if their experience reaches\n     * 500, their level is incremented and their experience is reset to 0. When an account reaches\n     * level 1, their address is pushed to the array ('levelOneOrHigher').\n     */\n    function increaseExperience(address _user, uint256 _flipAmount, bool _flipResult) internal {\n        if (_flipResult) experience[_user] += 10;\n        experience[_user] += _flipAmount / 1000000000000000;\n\n        if (experience[_user] >= 500) {\n            if(level[_user] == 0) levelOneOrHigher.push(_user);\n            level[_user] += 1;\n            experience[_user] -= 500;\n            emit LevelUp(_user, level[_user]);\n        }\n    }\n\n    /**\n     * @dev First txn in the flip process, ('choice') is true for heads or false for tails.\n     * Once called, this function sends a request to the ('vrfSigner') to settle the flip.\n     */\n    function deposit(bool choice) external payable {\n        require(\n            userFlipId[msg.sender] == 0,\n            \"accounts must flip after a deposit\"\n        );\n        require(\n            address(this).balance >= threshold,\n            \"flipping is currently paused\"\n        );\n        require(\n            msg.value == amounts[0] ||\n            msg.value == amounts[1] ||\n            msg.value == amounts[2] ||\n            msg.value == amounts[3] ||\n            msg.value == amounts[4] ||\n            msg.value == amounts[5],\n            \"invalid flip amount\"\n        );\n\n        userFlipId[msg.sender] = flipId;\n\n        requests[flipId] = FlipRequest({\n            id: flipId,\n            flipAmount: msg.value,\n            requester: msg.sender,\n            choice: choice\n        });\n\n        emit Deposit(msg.sender, flipId);\n\n        flipId++;\n    }\n\n    /**\n     * @dev Second txn in the flip process, throws if caller is not the vrf signer.\n     * This function increases experience, records statistics, and settles the coin flip.\n     */\n    function flip(uint64 id, bytes32 randomBytes) external {\n        require(msg.sender == rngSigner, \"unauthorized requester\");\n\n        uint256 amount = requests[id].flipAmount;\n        address user = requests[id].requester;\n        bool choice = requests[id].choice;\n        bool result = uint256(randomBytes) % 2 == 0;\n        bool win = choice == result;\n\n        emit Result(user, choice, result, amount);\n\n        delete userFlipId[user];\n        delete requests[id];\n\n        recordStatistics(user, choice, win);\n        increaseExperience(user, amount, win);\n\n        if (win) {\n            (bool successOne, ) = payable(user).call{value: 2 * amount - rngFee}(\"\");\n            (bool successTwo, ) = payable(rngSigner).call{value: rngFee}(\"\");\n            require(successOne && successTwo, \"transfers failed\");\n        }\n    }\n\n    // Owner functions\n    function setThreshold(uint256 _threshold) public onlyOwner {\n        threshold = _threshold;\n    }\n\n    function setRngFee(uint256 _rngFee) public onlyOwner {\n        rngFee = _rngFee;\n    }\n\n    function setFlipAmounts(uint256[6] memory _amounts) public onlyOwner {\n        amounts = _amounts;\n    }\n\n    function withdraw() public payable onlyOwner {\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success, \"transfer failed\");\n    }\n\n    function claimGas() public onlyOwner {\n        blast.claimMaxGas(address(this), owner());\n    }\n\n    receive() external payable {}\n}\n"},"src/IBlast.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IBlast {\n    function configureAutomaticYield() external;\n    function configureClaimableGas() external;\n    function claimMaxGas(address contractAddress, address recipientOfGas) external returns (uint256);\n}\n\n"},"src/IBlastPoints.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IBlastPoints {\n    function configurePointsOperator(address operator) external;\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}},"settings":{"remappings":["openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/","entropy-sdk-solidity/=lib/@pythnetwork/entropy-sdk-solidity/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@pythnetwork/=lib/@pythnetwork/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","libraries":{}}}
